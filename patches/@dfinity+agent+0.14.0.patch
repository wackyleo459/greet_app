diff --git a/node_modules/@dfinity/agent/lib/cjs/agent/http/index.js b/node_modules/@dfinity/agent/lib/cjs/agent/http/index.js
index 20c06db..442a8f9 100644
--- a/node_modules/@dfinity/agent/lib/cjs/agent/http/index.js
+++ b/node_modules/@dfinity/agent/lib/cjs/agent/http/index.js
@@ -220,7 +220,7 @@ class HttpAgent {
         const body = cbor.encode(transformedRequest.body);
         // Run both in parallel. The fetch is quite expensive, so we have plenty of time to
         // calculate the requestId locally.
-        const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })));
+        const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({reactNative: {textStreaming: true}}, transformedRequest.request), { body })));
         const [response, requestId] = await Promise.all([request, (0, request_id_1.requestIdOf)(submit)]);
         return {
             requestId,
@@ -302,17 +302,17 @@ class HttpAgent {
                 sender,
                 ingress_expiry: new transforms_1.Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS),
             },
+
         });
         // Apply transform for identity.
         return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);
     }
-    async readState(canisterId, fields, identity, 
+    async readState(canisterId, fields, identity, request) {
     // eslint-disable-next-line
-    request) {
         const canister = typeof canisterId === 'string' ? principal_1.Principal.fromText(canisterId) : canisterId;
         const transformedRequest = request !== null && request !== void 0 ? request : (await this.createReadStateRequest(fields, identity));
         const body = cbor.encode(transformedRequest.body);
-        const response = await this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
+        const response = await this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({ reactNative: { __nativeResponseType: "base64" }}, transformedRequest.request), { body }));
         if (!response.ok) {
             throw new Error(`Server returned an error:\n` +
                 `  Code: ${response.status} (${response.statusText})\n` +
@@ -352,7 +352,7 @@ class HttpAgent {
                 Authorization: 'Basic ' + btoa(this._credentials),
             }
             : {};
-        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), { headers }));
+        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), Object.assign({ reactNative: { __nativeResponseType: "base64" } }, { headers })));
         return cbor.decode(await response.arrayBuffer());
     }
     async fetchRootKey() {
diff --git a/node_modules/@dfinity/agent/lib/esm/agent/http/index.js b/node_modules/@dfinity/agent/lib/esm/agent/http/index.js
index 12b253a..31f0676 100644
--- a/node_modules/@dfinity/agent/lib/esm/agent/http/index.js
+++ b/node_modules/@dfinity/agent/lib/esm/agent/http/index.js
@@ -189,7 +189,7 @@ export class HttpAgent {
         const body = cbor.encode(transformedRequest.body);
         // Run both in parallel. The fetch is quite expensive, so we have plenty of time to
         // calculate the requestId locally.
-        const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body })));
+        const request = this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign({reactNative: {textStreaming: true}}, transformedRequest.request), { body })));
         const [response, requestId] = await Promise.all([request, requestIdOf(submit)]);
         return {
             requestId,
@@ -275,13 +275,12 @@ export class HttpAgent {
         // Apply transform for identity.
         return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);
     }
-    async readState(canisterId, fields, identity, 
+    async readState(canisterId, fields, identity, request) {
     // eslint-disable-next-line
-    request) {
         const canister = typeof canisterId === 'string' ? Principal.fromText(canisterId) : canisterId;
         const transformedRequest = request !== null && request !== void 0 ? request : (await this.createReadStateRequest(fields, identity));
         const body = cbor.encode(transformedRequest.body);
-        const response = await this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({}, transformedRequest.request), { body }));
+        const response = await this._fetch('' + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign({reactNative: { __nativeResponseType: "base64" }}, transformedRequest.request), { body }));
         if (!response.ok) {
             throw new Error(`Server returned an error:\n` +
                 `  Code: ${response.status} (${response.statusText})\n` +
@@ -321,7 +320,7 @@ export class HttpAgent {
                 Authorization: 'Basic ' + btoa(this._credentials),
             }
             : {};
-        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), { headers }));
+        const response = await this._requestAndRetry(() => this._fetch('' + new URL(`/api/v2/status`, this._host), Object.assign({ reactNative: { __nativeResponseType: "base64" } }, { headers })));
         return cbor.decode(await response.arrayBuffer());
     }
     async fetchRootKey() {
